# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import json
import logging
import os
from awslabs.cloudwatch_mcp_server.cloudwatch_metrics.constants import COMPARISON_OPERATOR_ANOMALY
from jinja2 import Environment, FileSystemLoader, select_autoescape
from typing import Any, Dict


logger = logging.getLogger(__name__)


class CloudFormationTemplateGenerator:
    """Generate CloudFormation JSON for CloudWatch Anomaly Detection Alarms using templates."""

    ANOMALY_DETECTION_ALARM_TEMPLATE = 'anomaly_detection_alarm.json'

    def __init__(self):
        """Initialize the CloudFormation template generator."""
        template_dir = os.path.join(os.path.dirname(__file__), 'templates')
        self.env = Environment(
            loader=FileSystemLoader(template_dir),
            autoescape=select_autoescape(['html', 'xml', 'json']),
        )

    def generate_template(self, alarm_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate CFN template for a single CloudWatch Alarm."""
        if not self._is_anomaly_detection_alarm(alarm_data):
            return {}

        # Process alarm data and add computed fields
        formatted_data = self._format_anomaly_detection_alarm_data(alarm_data)
        alarm_json = self._generate_anomaly_detection_alarm_resource(formatted_data)
        resources = json.loads(alarm_json)

        final_template = {
            'AWSTemplateFormatVersion': '2010-09-09',
            'Description': 'CloudWatch Alarms and Anomaly Detectors',
            'Resources': resources,
        }

        return final_template

    def _format_anomaly_detection_alarm_data(self, alarm_data: Dict[str, Any]) -> Dict[str, Any]:
        """Sanitise alarm data and add computed fields."""
        formatted_data = alarm_data.copy()

        # Generate alarm name if not provided
        if 'alarmName' not in formatted_data:
            metric_name = alarm_data.get('metricName', 'Alarm')
            namespace = alarm_data.get('namespace', '')
            formatted_data['alarmName'] = self._generate_alarm_name(metric_name, namespace)

        # Generate resource key (sanitized alarm name for CloudFormation resource)
        formatted_data['resourceKey'] = self._sanitize_resource_name(formatted_data['alarmName'])

        # Process threshold value
        threshold = alarm_data.get('threshold', {})
        formatted_data['sensitivity'] = threshold.get('sensitivity', 2)

        # Set defaults
        formatted_data.setdefault(
            'alarmDescription', 'CloudWatch alarm generated by CloudWatch MCP server.'
        )
        formatted_data.setdefault('statistic', 'Average')
        formatted_data.setdefault('period', 300)
        formatted_data.setdefault('evaluationPeriods', 2)
        formatted_data.setdefault('datapointsToAlarm', 2)
        formatted_data.setdefault('comparisonOperator', COMPARISON_OPERATOR_ANOMALY)
        formatted_data.setdefault('treatMissingData', 'missing')
        formatted_data.setdefault('dimensions', [])

        return formatted_data

    def _generate_anomaly_detection_alarm_resource(self, alarm_data: Dict[str, Any]) -> str:
        """Generate CloudWatch anomaly detection alarm template using Jinja2.

        Args:
            alarm_data: Alarm configuration data

        Returns:
            str: Generated CloudFormation template
        """
        template = self.env.get_template(self.ANOMALY_DETECTION_ALARM_TEMPLATE)
        alarm_resource = template.render(**alarm_data)

        return alarm_resource

    def _is_anomaly_detection_alarm(self, alarm_data: Dict[str, Any]) -> bool:
        return alarm_data.get('comparisonOperator') == COMPARISON_OPERATOR_ANOMALY

    def _generate_alarm_name(self, metric_name: str, namespace: str) -> str:
        """Generate alarm name from metric name and namespace."""
        return f'{metric_name.capitalize()}{namespace.replace("/", "").replace("AWS", "")}Alarm'

    def _sanitize_resource_name(self, name: str) -> str:
        """Sanitize name for CloudFormation resource key."""
        sanitized = name.replace('-', '').replace('_', '').replace('/', '').replace(' ', '')
        # Validate CloudFormation naming requirements
        if not sanitized or not sanitized[0].isalpha():
            logger.warning(f'Invalid resource name: {sanitized} (must start with letter)')
            sanitized = 'Resource' + sanitized
        if len(sanitized) > 255:
            logger.warning(f'Resource name too long ({len(sanitized)} chars), truncating')
            sanitized = sanitized[:255]
        return sanitized
